# 数据的标准化

人是一种很健忘的生物,尤其是在许多人做同一个事情的时候.这点在工程上体现的尤其明显.数据标准化目的就是为了确定一个标准,让参与的人使用同一标准处理同类数据,以避免因为忘记口头定义而丢失信息的情况.

## 每处的数据都应该标准化

从数据采集,到数据流转的各处,每处数据都应该标准化,有对应文档,有版本管理,这样虽然繁琐,但可以有效的避免数据混乱.做到任何一处可追溯.而且机制一旦建立实际上繁琐的程度有限.

## 使用兼容性好的通用结构化数据格式序列化数据

数据标准化最忌讳的是自己为数据做编码解码.这种行为往往是偷懒的结果,很容易最后尾大不掉.最直接的方案就是使用现有的兼容性好的通用结构化数据格式.比较推荐的有两种:

+ [Protobuf](http://blog.hszofficial.site/TutorialForDataScience/#/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%AF%87/%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/Protobuf)

+ [JSON](http://blog.hszofficial.site/TutorialForDataScience/#/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%AF%87/%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/JSON)结合[JSONSchema](http://blog.hszofficial.site/TutorialForDataScience/#/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%AF%87/%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/=)

我们从中根据自己的需求选择一种就好,尽量不要两种混用,造成管理上的混乱.

### 使用protobuf

protobuf是目前最快最小的序列化协议,由google开发推动,已经广泛应用于游戏开发,深度学习甚至嵌入式领域.它几乎支持所有主流编程语言.

protobuf是结构化的,需要使用专用语法[proto3](https://developers.google.com/protocol-buffers/docs/proto3)先定义数据的格式(schema)文件`*.proto`,然后使用专用的编译工具[protoc](https://developers.google.com/protocol-buffers/docs/downloads)编译到需要的对应编程语言成为一个模块,
最后引用这个模块调用其中的接口就可以针对定义好格式的数据实例进行序列化和反序列化.

使用python做protobuf的序列化反序列化操作可以看[这篇](http://blog.hszofficial.site/TutorialForPython/%E8%AF%AD%E6%B3%95%E7%AF%87/%E6%96%87%E6%9C%AC%E4%B8%8E%E5%AD%97%E8%8A%82%E5%BA%8F/%E5%BA%8F%E5%88%97%E5%8C%96.html#protobuf)

使用protobuf的优势是

1. 性能好,因为实际上格式信息都在编译好的模块中,实际传输的信息就可以很小,也得益于此消息可以很快的传递.pb应该是目前性能最好的结构化序列化协议了
2. 代码即文档,格式文件`*.proto`本身可读性不错,也有版本管理相关的关键字,而且格式严谨完全可以直接作为文档使用.

劣势也是有的:

1. 可读性,序列化后结果是bytes,基本不可读,因此不容易发现错误
2. 版本更新麻烦,更新依赖格式文件必须编译好后作为模块引用,在不使用容器技术或者批量部署工具的情况下如果要在多台机器上部署更新将会非常考验运维的耐心.
3. 只能验证数据类型,无法验证数据内容.

总结起来就是追求性能就用protobuf

### 使用json结合json schema

json是一种半结构化数据格式,几乎任何编程语言都支持json格式,因此使用起来十分方便;而且兼容性非常好,比如python中它可以直接反序列化为字典,js中更是直接可以作为对象处理;同时json也在各种数据库中作为一种数据类型被支持.

单纯使用json并不好,因为不利于数据验证和版本管理,因此这边可以引入[json schema](http://json-schema.org/)来实现这两个功能.

使用python做json的序列化反序列化操作可以看[这篇](http://blog.hszofficial.site/TutorialForPython/%E8%AF%AD%E6%B3%95%E7%AF%87/%E6%96%87%E6%9C%AC%E4%B8%8E%E5%AD%97%E8%8A%82%E5%BA%8F/%E5%BA%8F%E5%88%97%E5%8C%96.html#json%E7%94%A8%E4%BA%8E%E6%B6%88%E6%81%AF%E4%BC%A0%E8%BE%93)

使用python做json的数据验证操作可以看[这篇](http://blog.hszofficial.site/TutorialForPython/%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8%E7%AF%87/%E7%BB%93%E6%9E%84%E6%95%B0%E6%8D%AE%E9%AA%8C%E8%AF%81.html)

使用json的优势是

1. 可读性,本身json就是一种基于文本的序列化格式,人可以直接读懂.
2. 代码即文档,格式文件`schema.json`本身可读性不错,也有版本管理相关的关键字,更可以设定数值型的上下界,字符串的re匹配等内容校验功能,数据校验更加严格,而且格式严谨完全可以直接作为文档使用.
3. 可以方便的部署专门的格式文件服务统一管理.因为实际上格式文件还是个json文件,起一个http服务器就可以了,而版本更新更加是可以直接通过重载文件或者直接http访问格式服务器拉取最新格式文件即可.完全可以做到热更新.

劣势也是有的:

1. 性能,json是基于文本的序列化格式,必然很大,在序列化后的数据大小上性能就比较差了

总结起来就是追求便利就用json+jsonschema

## 数据格式版本管理

数据标准化是一个必须在顶层做设计的东西,而且很难做渐进式迭代.因此必须在开始就设计好.每次更新都必须小心谨慎,还要考虑兼容性问题.

数据格式的版本管理主要是两个方面:

1. 版本形式和更新模式的约定,这个部分关心的是如何更新数据格式的版本

2. 格式文件获取方式约定,这个部分关心的是外部如何探知版本是否更新了,如何获取到需要版本的格式文件

### 版本形式和更新模式的约定

通常我们用形如`x.y.z`的版本号来区分版本,x代表主版本,一般是重构才会修改;y表示特性修改版本,增删字段护着修改字段含义类型才会更新,z表示常规更新版本,一般是修改验证匹配规则或者描述才会更新.x不同的通常完全不兼容,y不同的保持最近3个版本兼容,z则要求完全兼容.

我们的数据应该在序列化后加上被序列化的版本号,数据创建的时间戳等元信息以方便程序按版本号做反序列化.我们以json为例

```json
{
"meta":{
"version":"1.2.3",
"source_id":"xxxxx",
"createdby": "server A",
"ctime":1234125412
},
"data":{
 ...
}
}
```

注意,上面的`source_id`为一个全局唯一的id号,在数据进入系统时生成,用于追踪每条进入系统的原始数据最终的流转情况

### 格式文件获取方式约定

现在的软件/系统开发往往时迭代更新的,在数据方面就很容易出现依赖的数据形式更新了版本但处理用的程序并没有做好对接的情况,这种时候就需要约定好格式文件的获取方式和格式文件更新了这个事件的通知方式.

最原始的方法自然是--更新了数据形式后用外部方式(群发邮件/拉个qq群)手工通知依赖这个数据的下游并向他们发送格式文件.这种方式问题在于:

1. 上游的数据开发需要知道有哪些下游,这个在复杂系统中几乎是不可能的
2. 下游有没有收到这个消息及时跟进无法追踪

因此比较好的一种解决方式是起一个中心化的RESTful服务管理所有格式文件,并且提供一个websocket接口向整个组织的人推送版本更新行为,并且需要可以点击确认提供反馈,这个系统就需要运维开发人员来做了.
